# 位运算解题

### 1. 判断字符是否唯一

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

1. 示例 1

   输入: s = "leetcode"

   输出: false 

   

2. 示例 2

   输入: s = "abc"
   
   输出: true

限制：

- $0 <= len(s) <= 100$
- 如果你不使用额外的数据结构，会很加分。



#### 解法

我们可以使用一个 int 类型的变量（下文用 **mark** 表示）来代替长度为 $26$ 的 bool数组。假设这个变量占 26 个 bit（在多数语言中，这个值一般不止26，但是，我们只需要后26位即可）。

把它看成 **000...00**(26个0)，这 26 个bit对应着 26 个字符，对于一个字符 $c$，检查对应下标的 bit 值即可判断是否重复。那么难点在于如何检查。这里我们可以通过位运算来完成。

首先计算出字符 char 离 'a' 这个字符的距离，即我们要位移的距离，用 **move\_bit** 表示，那么使用左移运算符 **1 << move\_bit** 则可以得到对应下标为 1，其余下标为 0 的数，如字符 char = 'c'，则得到的数为 **000...00100**，将这个数跟 **mark** 做 **与运算**，由于这个数只有一个位为 1，其他位为 0，那么与运算的结果中，其他位肯定是0，而对应的下标位是否为 0 则取决于之前这个字符有没有出现过，若出现过则被标记为 1，那么与运算的结果就不为 0；若之前没有出现过，则对应位的与运算的结果也是 0，那么整个结果也为 0。

最后，对于没有出现过的字符形成的数字，我们将其跟 **mark** 做 **或运算**，将对应下标位的值置为1。

```java
public static boolean isUnique(String astr) {
    int aa = 0;
    int cc = 1;
    for (int i = 0; i < astr.length(); i++) {
      char t = astr.charAt(i);
      int offset = t - 'a';

      int bb = cc << offset;
      
      // 判断该字符是否已经出现
      if ((aa & bb) != 0) {
        return false;
      }
      
      // 该字符之前未出现，标记该字符
      aa |= bb;
    }

    return true;
  }

```

---



### 2. 回文排列

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。

1. 示例1

   输入："tactcoa"

   输出：true（排列有"tacocat"、"atcocta"，等等）



#### 解法

利用位运算中的 **异或** 运算。

对128位的 ASCII 码的字符，如果是用 int 类型，需要 4 位，但如果使用 long 类型，只需要两位就行了。一个记录 $0-63$，一个记录 $64-127$。每一位对应一个字符。同时对 Long 型的 **1L** 进行左移操作以标识字符串中各个字符。然后进行 **异或** 运算。这样，偶数个字符对应的标识位就会为 0，奇数个字符对应的标识位就会为 1。最后统计两个记录数中 1 的个数即可，若是回文排列，则 1 的个数只能是 0或1。

1. long 型数字，highBit 记录 64-127 位字符，lowBit 记录 0-63 位字符，初值均为 0
2. 遍历字符串，对其中的每一个字符，利用 ASCII 码进行计算确定，$0-63$ 位左移对应的位数，$64-127$ 位减去 64 后左移对应的位数，然后对长整型的 **1L** 进行移位；
3. 将移位后的数组与 highBit 或 lowBit 进行 **异或** 计算；
4. 统计两个记录数中的 1 的个数。

```java
public boolean canPermutePalindrome(String s) {
    long highBit = 0, lowBit = 0;
    for(char ch: s.toCharArray()) {
        if(ch > 63) {
            highBit ^= (1L << (ch-64));
        } else {
            lowBit ^= (1L << ch);
        }
    }
    return Long.bitCount(highBit) + Long.bitCount(lowBit) <= 1;
}

```

---



### 3. 翻转数位

给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。

1. 示例 1

   输入: num = 1775 (11011101111)

   输出: 8

2. 示例 2

   输入: num = 7(0111)

   输出: 4



#### 解法：动态规划，逐位遍历

本题使用动态规划解决比较容易：使用用两个动态规划数组 current[]，reverse[]

- **current[i]** 表示包含第 $i$ 位的从num二进制低位至第 $i$ 位 连续1的最长长度。
- **reverse[i]** 表示包含第 $i$ 位的从低位到第 $i$ 位最多翻转1个0->1 的连续1的最长长度。
- 用 **num[i]** 表示整数 num 第 $i$ 位的值

当 **num[i]=1** 时，**current[i] = current[i-1]+1**，因为 **current[i-1]** 一定包含 **i-1** 位，也就是和第 $i$ 位连续，所以前 $i-1$ 的最大长度连上第 $i$ 位的长度就等于 **current[i]**，同理 **reverse[i] = reverse[i-1]+1**;

当 **num[i]=0** 时，连续中断，**current[i]=0**，而 **reverse[i]** 允许翻转1次，但是**reverse[i]** 又必须包含第 $i$ 位，也就是说只能翻转第 $i$ 位，所以前面不能出现翻转，必须全是1，这个长度恰好就是 **current[i-1]**，所以 **reverse[i] = current[i-1]+1**。

遍历 num 所有位数，也就是32位后，reverse 数组中的最大值就是答案。

状态方程：

1. **current[i] = num[i] == 1? current[i-1]+1: 0**
2. **reverse[i] = num[i] == 1? reverse[i-1]+1: current[i-1]+1**

观察状态方程，我们发现 current 和 reverse 第 $i$ 位只和第 $i-1$ 位有关，所以可以把动态数组优化成两个变量 current 和 reverse，同时更新最大值 max 并作为结果返回。

```java
public int reverseBits(int num) {
    int current = 0;
    int reverse = 0;
    int max = 0;
    for (int i = 0; i < 32; i++) {
        if ((num & 1) == 1) {
            current++;
            reverse++;
        } else {
            reverse = current+1;
            current = 0;
        }
        if (reverse > max) {
            max = reverse;
        }
        num >>= 1;
    }
    return max;
}

```

---



### 4. 整数转换

整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

1. 示例1

   输入：A = 29（11101），B = 15（01111）

   输出：2

2. 示例2

   输入：A = 1，B = 2

   输出：2

注意：A，B范围在[-2147483648, 2147483647]之间



#### 解法一：逐位遍历

由于 A，B 均不超过 32 位，因此采用逐位遍历的方式，从低位开始遍历 A 与 B，采用 **&1** 计算比较遍历到的位是否一致，采用 **count** 计数，最后返回 count 即可。

```java
public int convertInteger(int A, int B) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        if ((A&1) != (B&1)) {
            count++;
        }
        A >>= 1;
        B >>= 1;
    }
    return count;
}

```



#### 解法二：异或运算

**异或运算** 能找出 A、B 中的不同位。因此首先对 A、B 进行异或运算，在统计异或结果中 **1** 的个数即可。

把 C 中的 1 都变为0，需要几次，即为C中1的个数。**C & (C-1)** 会把 C 的最右边的 1 变为0，其余不变。

```java
public int convertInteger(int A, int B) {
    int count = 0;
    int C = A^B;
    while(C != 0) {
        C = C & (C-1);
        count++;
    }
    return count;
}

```

---



### 5. 配对交换

配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

1. 示例1

   输入：num = 2（0b10）

   输出：1(0b01)

2. 示例2

   输入：num = 3

   输出：3

提示：num的范围在 [0, 2^30 - 1] 之间，不会发生整数溢出。



#### 解法：

**分别取出奇数位和偶数位，移位后做 或运算。**

题目规定 num 是 int 范围的数，则

- 0x55555555 = 0b0101_0101_0101_0101_0101_0101_0101_0101
- 0xaaaaaaaa = 0b1010_1010_1010_1010_1010_1010_1010_1010

用 num 分别与这两个数做 与运算，就可以把奇数位和偶数位取出来，然后：

1. 左移奇数位，右移偶数位；
2. 奇数位和偶数位做或运算并返回。

```java
public int exchangeBits(int num) {
    // 奇数位
    int odd = num & 0x55555555;
    // 偶数位
    int even = num & 0xaaaaaaaa;

    odd <<= 1;
    even >>= 1;
    
    return odd | even;
}

```



---

# HashMap

### 1. 字符串能否重排

给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

1. 示例 1

   输入: s1 = "abc", s2 = "bca"

   输出: true 

2. 示例 2

   输入: s1 = "abc", s2 = "bad"

   输出: false

说明：

- 0 <= len(s1) <= 100
- 0 <= len(s2) <= 100

#### 解法

一般思路就是利用哈希表记录字符以及各个字符的数量，两个字符串能重排得到相同的字符，则两个字符串的字符以及字符数量均相等。遍历两个字符串，判断两个字符串能否重排。

另一种思路就是将两个字符串以字符数组的形式保存，再进行排序。同步遍历两个排序后的数组，若出现字符不一致的情况，则判定不能重排即可。

```java
public boolean CheckPermutation(String s1, String s2) {
    if(s1.length() != s2.length()) {
        return false;
    }
    char ch;
    HashMap<Character, Integer> chars = new HashMap<Character, Integer>();
    for (int i = 0; i < s1.length(); i++) {
        ch = s1.charAt(i);
        // Java 的哈希表不能直接修改值，只能以 put 的形式来进行修改
        chars.put(ch, chars.getOrDefault(ch,0)+1);
    }
    for (int i = 0; i < s2.length(); i++) {
        ch = s2.charAt(i);
        chars.put(ch, chars.getOrDefault(ch,0)-1);
    }
    for(int x: chars.values()) {
        if (x != 0) {
            return false;
        }
    }
    return true;
}

```

---

# 指针

### 1. 字符串压缩

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 aabcccccaaa 会变为 a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

1. 示例1

   输入："aabcccccaaa"

   输出："a2b1c5a3"

2. 示例2

   输入："abbccd"

   输出："abbccd"

   解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。

提示：字符串长度在[0, 50000]范围内。



#### 解法

![ccw-01-06.001.png](算法练习.assets/1638377048-wXAPoR-ccw-01-06.001.png)

考虑借助双指针 $i$ , $j$ 解题，算法流程为：

1. 令 i 指向字符串的首个字符，j 向前遍历，直到访问到不同字符时停止，此时 $j−i$ 便是首个字符的连续出现次数，即可完成首个字符的压缩操作。
2. 接下来，从下个字符开始，重复以上操作，直到遍历完成即可。
3. 根据题目要求，最终返回「原字符串」和「压缩字符串」中长度较短的那个。

```java
public String compressString(String S) {
    int i=0, j=0, ls = S.length();
    StringBuilder sb = new StringBuilder();
    while(i < ls) {
        while(j < ls && S.charAt(i) == S.charAt(j)) {
            j++;
        }
        sb.append(S.charAt(i)).append(j-i);
        i = j;
    }
    return sb.length() < S.length() ? sb.toString(): S;
}

```



---

# 链表

这里给出单链表的 Java 实现。

```java
public class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
    }

}

```



### 1. 移除重复节点

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。



#### 解法一：哈希表

对给定的链表进行遍历，并用一个集合保存未出现过的值，同时删除已出现的值，为了方便操作，可增加一个哨兵节点指向头结点。这样同时解决链表为空时算法出现异常的问题。

```java
public ListNode removeDuplicateNodes(ListNode head) {
    HashSet<Integer> vals = new HashSet<Integer>();
    ListNode pre = new ListNode(0);
    pre.next = head;
    ListNode node = head;
    while (node != null) {
        if(vals.contains(node.val)) {
            pre.next = node.next;
            node = node.next;
        } else {
            vals.add(node.val);
            pre = node;
            node = node.next;
        }
    }
    return head;
}

```



#### 解法二：双重遍历

考虑题目描述中的「进阶」部分，是否存在一种不使用临时缓冲区（也就是方法一中的哈希表）的方法呢？

不幸的是，在保证方法一时间复杂度 $O(N)$ 的前提下，是不存在这样的方法的。因此我们需要增加时间复杂度，使得我们可以仅使用常数的空间来完成本题。一种简单的方法是，我们在给定的链表上使用两重循环，其中第一重循环从链表的头节点开始，枚举一个保留的节点，这是因为我们保留的是「最开始出现的节点」。第二重循环从枚举的保留节点开始，到链表的末尾结束，将所有与保留节点相同的节点全部移除。

第一重循环枚举保留的节点本身，而为了编码方便，第二重循环可以枚举待移除节点的前驱节点，方便我们对节点进行移除。这样一来，我们使用「时间换空间」的方法，就可以不使用临时缓冲区解决本题了。

```java
public ListNode removeDuplicateNodes(ListNode head) {
    ListNode ob = head;
    while (ob != null) {
        ListNode oc = ob;    // 不使用 ob.next，这是为了防止在链表只有一个节点的情况下，出现异常。
        while (oc.next != null) {
            if (oc.next.val == ob.val) {
                oc.next = oc.next.next;
            } else {
                oc = oc.next;
            }
        }
        ob = ob.next;
    }
    return head;
}

```



### 2. 公共节点

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](算法练习.assets/160_statement.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

1. 示例 1

   输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
   
   输出：Intersected at '8'
   
   解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

![img](算法练习.assets/160_example_1.png)



2. 示例 2

   输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
   
   输出：null
   
   解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。

![img](算法练习.assets/160_example_3.png)

提示：

1. listA 中节点数目为 m
2. listB 中节点数目为 n
3. 0 <= m, n <= 3 * 104
4. 1 <= Node.val <= 105
5. 0 <= skipA <= m
6. 0 <= skipB <= n
7. 如果 listA 和 listB 没有交点，intersectVal 为 0
8. 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]



#### 解法：双指针

设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a，「链表 headB」的节点数量为 b，「两链表的公共尾部」的节点数量为 c，则有：

- 头节点 headA 到 node 前，共有 $a−c$ 个节点；
- 头节点 headB 到 node 前，共有 $b−c$ 个节点；

![Picture1.png](算法练习.assets/1615224578-EBRtwv-Picture1.png)



考虑构建两个节点指针 A , B 分别指向两链表头节点 headA , headB ，做如下操作：

1. 指针 A 先遍历完链表 headA，再开始遍历链表 headB，当走到 node 时，共走步数为：
   $$
   a + (b - c)
   $$
   
2. 指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：
   $$
   b + (a - c)
   $$

如下式所示，此时指针 A , B 重合，并有两种情况：
$$
a + (b - c) = b + (a - c)
$$

- 若两链表有公共尾部，即$c>0$：指针 A , B 同时指向「第一个公共节点」node。
- 若两链表无公共尾部，即$c=0$：指针 A , B 同时指向 null。

因此返回 A 即可。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode A = headA, B = headB;
    while (A != B) {
        A = (A != null ? A.next : headB);
        B = (B != null ? B.next : headA);
    }
    return A;
}

```



---

# 二叉树

### 1. 最小二叉搜索树

给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

1. 示例

   给定有序数组: [-10,-3,0,5,9],

   一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

   ```
        0 
       / \ 
     -3   9 
     /   / 
   -10  5 
   ```

   

#### 解法：递归

题中说了要转换为一棵高度平衡的二叉搜索树，并且数组又是排过序的，这就好办了，我们可以使用递归的方式，每次取数组中间的值比如m作为当前节点，m前面的值作为他左子树的结点值，m后面的值作为他右子树的节点值，示例中一个可能的结果是：

![image.png](算法练习.assets/8a549e664d787eb23f35b3e6571fc40b200d1958fb0d91ca1392e8961ce85f15-image.png)

代码如下：

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return ArrayToBST(nums, 0, nums.length - 1);
}

public TreeNode ArrayToBST(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = start + (end-start)/2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = ArrayToBST(nums, start, mid-1);
    root.right = ArrayToBST(nums, mid+1, end);
    return root;
}

```

---



### 2. 检查平衡性

实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。

1. 示例 1

   给定二叉树 [3,9,20,null,null,15,7]

   ```
       3
      / \
     9  20
       /  \
      15   7
   ```

   返回 true 。

   

2. 示例 2：

   给定二叉树 [1,2,2,3,3,null,null,4,4]

   ```
         1
        / \
       2   2
      / \
     3   3
    / \
   4   4
   ```

   返回 false 。



#### 解法：递归遍历

这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。

##### 1. 自顶向下

定义函数 $height$，用于计算二叉树中的任意一个节点 $p$ 的高度：

$$
\texttt{height}(p) = \begin{cases} 0 & p \text{ 是空节点}\\ \max(\texttt{height}(p.left), \texttt{height}(p.right))+1 & p \text{ 是非空节点} \end{cases}
$$
有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。

```java
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }
    return Math.abs(height(root.left)-height(root.right)) <= 1 && (isBalanced(root.left)) && (isBalanced(root.right));
}

public int height(TreeNode node) {
    if (node == null) {
        return 0;
    }
    return Math.max(height(node.left), height(node.right)) + 1;
}

```



##### 2. 自底向上

方法一由于是自顶向下递归，因此对于同一个节点，函数 $\texttt{height}$ 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 $\texttt{height}$ 只会被调用一次。

自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 $−1$。如果存在一棵子树不平衡，则整个二叉树一定不平衡。

```java
public boolean isBalanced(TreeNode root) {
    return height(root) >= 0;
}

public int height(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = height(root.left);
    int rightHeight = height(root.right);
    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {
        return -1;
    } else {
        return Math.max(leftHeight, rightHeight) + 1;
    }
}

```



