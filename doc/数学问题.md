## 1 阶乘尾数

设计一个算法，算出 n 阶乘有多少个尾随零。

1. 示例 1

   输入: 3

   输出: 0

   解释: 3! = 6, 尾数中没有零。

2. 示例 2

   输入: 5

   输出: 1

   解释: 5! = 120, 尾数中有 1 个零.



### 解法

1. 尾数的0都是某一个数乘以10得到的
2. 只有5和一个偶数相乘会得到10或10的倍数，所以有几个5就有几个10，就有几个0
3. 在数的阶乘中，偶数的个数明显多于5的个数，所以只要计算出阶乘中每个数的因数中5的个数，即可得到0的个数。比如26! = 403291461126605635584000000‬，有6个0，【5贡献一个0，10贡献一个0，15贡献一个0，20贡献一个0，25贡献两个0】
4. 但因为25和它的倍数，如50，里面都有两个5，所以遇到25和其倍数都要+2。同理125和它的倍数，如250，里面都有3个5，所以遇到125和其倍数都要+3。所以从n除完5后，再除以25，125，依次类推，这样才不会遗漏。

```java
public int trailingZeroes(int n) {
    int ans = 0;
    while (n > 0) {
        ans += n/5;    // 以 5个数 为一组，有多少组就说明有多少个5
        n /= 5;        // 25、125 等数字中有多个 5，为此，再以 25个数为一组，有多少组就有多少个5，添加到以统计的 5 的个数中去。125等情况以此类推
    }
    return ans;
}

```

---



## 2 杨辉三角

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

1. 示例 1

   输入: numRows = 5

   输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

   

2. 示例 2

   输入: numRows = 1

   输出: [[1]]



### 解法

杨辉三角，是二项式系数在三角形中的一种几何排列。它是中国古代数学的杰出研究成果之一，它把二项式系数图形化，把组合数内在的一些代数性质直观地从图形中体现出来，是一种离散型的数与形的结合。

杨辉三角具有以下性质：

1. 每行数字左右对称，由 1 开始逐渐变大再变小，并最终回到 1。
2. 第 n 行（从 0 开始编号）的数字有 n+1 项，前 n 行共有 $\frac{n(n+1)}{2}$ 个数。
3. 第 n 行的第 m 个数（从 0 开始编号）可表示为可以被表示为组合数 $\mathcal{C}(n,m)$，记作 $\mathcal{C}_n^m$ 或 $\binom{n}{m}$，即为从 n 个不同元素中取 m 个元素的组合数。我们可以用公式来表示它：$\mathcal{C}_n^m=\dfrac{n!}{m!\times (n-m)!}$。
4. 每个数字等于上一行的左右两个数字之和，可用此性质写出整个杨辉三角。即第 n 行的第 i 个数等于第 n−1 行的第 i−1 个数和第 i 个数之和。这也是组合数的性质之一，即 $\mathcal{C}_n^i=\mathcal{C}_{n-1}^i+\mathcal{C}_{n-1}^{i-1}$。
5. $(a+b)^n$ 的展开式（二项式展开）中的各项系数依次对应杨辉三角的第 n 行中的每一项。

依据性质 4，我们可以一行一行地计算杨辉三角。每当我们计算出第 i 行的值，我们就可以在线性时间复杂度内计算出第 i+1 行的值。

```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> ret = new ArrayList<List<Integer>>();
    for (int i = 0; i < numRows; ++i) {
        List<Integer> row = new ArrayList<Integer>();
        for (int j = 0; j <= i; ++j) {
            if (j == 0 || j == i) {
                row.add(1);
            } else {
                row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j));
            }
        }
        ret.add(row);
    }
    return ret;
}

```

---



## 3 杨辉三角 ||

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。



### 解法

由组合数公式 $\mathcal{C}_n^m=\dfrac{n!}{m!(n-m)!}$，可以得到同一行的相邻组合数的关系：
$$
\mathcal{C}_n^m= \mathcal{C}_n^{m-1} \times \dfrac{n-m+1}{m}
$$
由于 $\mathcal{C}_n^0=1$，利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。

```java
public List<Integer> getRow(int rowIndex) {
    List<Integer> row = new ArrayList<Integer>();
    row.add(1);
    for (int i = 1; i <= rowIndex; ++i) {
        row.add((int) ((long) row.get(i - 1) * (rowIndex - i + 1) / i));
    }
    return row;
}

```

---



## 4 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
- 如果这个过程 结果为 1，那么这个数就是快乐数。
- 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

 

1. 示例 1

   输入：n = 19

   输出：true

   解释：$1^2 + 9^2 = 82、8^2 + 2^2 = 6^8、6^2 + 8^2 = 100、1^2 + 0^2 + 0^2 = 1$

2. 示例 2

   输入：n = 2

   输出：false



### 解法一：哈希表检测循环

我们可以先举几个例子。我们从 7 开始。则下一个数字是 49，然后下一个数字是 97。我们可以不断重复该的过程，直到我们得到 1。因为我们得到了 1，我们知道 7 是一个快乐数，函数应该返回 true。

![fig1](https://assets.leetcode-cn.com/solution-static/202/202_fig1.png)

再举一个例子，让我们从 116 开始。通过反复通过平方和计算下一个数字，我们最终得到 58，再继续计算之后，我们又回到 58。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 1。所以对于 116，函数应该返回 false。

![fig2](https://assets.leetcode-cn.com/solution-static/202/202_fig2.png)



根据我们的探索，我们猜测会有以下三种可能。

1. 最终会得到 1。
2. 最终会进入循环。
3. 值会越来越大，最后接近无穷大。

第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 1 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。

| Digits | Largest       | Next |
| ------ | ------------- | ---- |
| 1      | 9             | 81   |
| 2      | 99            | 162  |
| 3      | 999           | 243  |
| 4      | 9999          | 324  |
| 13     | 9999999999999 | 1053 |

对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。

```java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<Integer>();
    while (n != 1 && !set.contains(n)) {
        set.add(n);
        n = getNext(n);
    }
    return n == 1;
}

public int getNext(int n) {
    int ans = 0;
    int d = 0;
    while (n != 0) {
        d = n % 10;
        n = n / 10;
        ans += (d*d);
    }
    return ans;
}

```





### 解法二：龟兔赛跑算法

通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。因此，

1. 如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。
2. 如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。

```java
public boolean isHappy(int n) {
    int slow = n;
    int fast = getNext(n);
    while (fast != 1 && fast != slow ) {
        fast = getNext(getNext(fast));
        slow = getNext(slow);
    }
    return fast == 1;
}

public int getNext(int n) {
    int ans = 0;
    int d = 0;
    while (n != 0) {
        d = n % 10;
        n = n / 10;
        ans += (d*d);
    }
    return ans;
}

```

---



## 5 回文数

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数：是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

> 注意：不将整数转为字符串来解决这个问题

 

**示例 1：**

```
输入：x = 121
输出：true
```



**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```



**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

 

**提示：**

- $-2^{31} <= x <= 2^{31} - 1$



### 解法：数字反转一半

将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。

但是，如果反转后的数字大于 $\text{int.MAX}$，我们将遇到整数溢出问题。

为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 $\text{int}$ 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 $1221$，我们可以将数字 `1221` 的后半部分从 `21` 反转为 `12`，并将其与前半部分 `12` 进行比较，因为二者相同，我们得知数字 $1221$​ 是回文。

首先，我们应该处理一些临界情况。

1. 所有负数都不可能是回文，所以我们可以对所有负数返回 false。
2. 除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。

现在，让我们来考虑如何反转后半部分的数字。

对于数字 $1221$，如果执行 $1221 % 10$，我们将得到最后一位数字 `1`，要得到倒数第二位数字，我们可以先通过 `除以 10` 把最后一位数字从 $1221$​ 中移除，$1221 / 10 = 122$，再求出上一步结果除以 10 的余数，$122 % 10 = 2$，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，$1 * 10 + 2 = 12$，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。



```java
public boolean isPalindrome(int x) {
    // 特殊情况：
    // 如上所述，当 x < 0 时，x 不是回文数。
    // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
    // 则其第一位数字也应该是 0
    // 只有 0 满足这一属性
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return false;
    }

    int revertedNumber = 0;
    while (x > revertedNumber) {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }

    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
    return x == revertedNumber || x == revertedNumber / 10;
}
```

---



## 6 Excel表列名

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

 

**示例 1：**

```
输入：columnNumber = 1
输出："A"
```

**示例 2：**

```
输入：columnNumber = 28
输出："AB"
```

**示例 3：**

```
输入：columnNumber = 701
输出："ZY"
```

**示例 4：**

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```

 

**提示：**

- `1 <= columnNumber <= 231 - 1`



### 解法

如果列名称的长度为 $n$，每一位对应的序号为 $[a_{n-1}, a_{n-2}, \ldots, a_0]$，其中对于任意 $0 \le i < n$ 都有 $1 \le a_i \le 26$，则列名称对应的列序号为：
$$
\textit{number} = \sum_{i=0}^{n-1} a_i \times 26^i
$$
将列序号转换成列名称，则是在已知 $\textit{number}$ 的情况下，解出 $a_0$ 到 $a_{n-1}$ 的值。

分离出 $a_0$ 项，提出其余项的公因数 $26$，上式可以改写为：
$$
\textit{number} = a_0 + 26 \times \sum_{i=1}^{n-1} a_i \times 26^{i-1}
$$
将等式两边同时减 $1$，得：
$$
\textit{number} - 1 = (a_0 - 1) + 26 \times \Big(\sum_{i=1}^{n-1} a_i \times 26^{i-1}\Big)
$$
由于 $0 \le a_0 - 1 \le 25$，由上式可知，$a_0−1$ 是 $number−1$ 除以 $26$ 的余数。

这样我们就得到了 $a_0$ 的值。

在得到 $a_0$ 的值之后，令 $\textit{number}' = \dfrac{\textit{number} - a_0}{26}$，则有：
$$
\textit{number}' = \sum_{i=1}^{n-1} a_i \times 26^{i-1} = a_1 + 26 \times \sum_{i=2}^{n-1} a_i \times 26^{i-2}
$$
于是使用同样的方法，可以得到 $a_1$ 的值。

上述过程是一个循环的过程，直至 $\textit{number}'=0$ 时停止。此时我们就得到了 $a_0$ 到 $a_{n-1}$ 的值。拼接这些值对应的字母，即得到了答案。

代码实现时，由于我们计算列名称的顺序是从右往左，因此需要将拼接后的结果反转。

```java
public String convertToTitle(int columnNumber) {
    StringBuffer sb = new StringBuffer();
    while (columnNumber > 0) {
        int a0 = (columnNumber - 1) % 26 + 1;
        sb.append((char)(a0 - 1 + 'A'));
        columnNumber = (columnNumber - a0) / 26;
    }
    return sb.reverse().toString();
}
```

---



## 7 
