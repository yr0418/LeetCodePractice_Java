## 1. 环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

1. 示例 1

   输入：head = [3,2,0,-4], pos = 1

   输出：true

   解释：链表中有一个环，其尾部连接到第二个节点。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)



2. 示例 2

   输入：head = [1], pos = -1

   输出：false

   解释：链表中没有环。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)



### 解法：龟兔赛跑算法

假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。

我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

**注意：**

为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？因为我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}

```

---



## 2. 移动0

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

1. 示例 1

   输入: nums = [0,1,0,3,12]

   输出: [1,3,12,0,0]



### 解法：双指针

这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点x，然后把所有小于等于x的元素放到x的左边，大于x的元素放到其右边。

这里我们可以用 0 当做这个中间点，把不等于 0 的放到中间点的左边，等于 0 的放到其右边。这里的中间点就是 0 本身，所以实现起来比快速排序简单很多，我们使用两个指针 i 和j，只要 $nums[i]!=0$，我们就交换 nums[i] 和 nums[j]。

请对照动态图来理解：

![283_2.gif](https://pic.leetcode-cn.com/36d1ac5d689101cbf9947465e94753c626eab7fcb736ae2175f5d87ebc85fdf0-283_2.gif)

```java
public void moveZeroes(int[] nums) {
    if(nums==null) {
        return;
    }
    // 两个指针i和j
    int j = 0;
    for(int i=0;i<nums.length;i++) {
        // 当前元素 != 0，就把其交换到左边，等于 0 的交换到右边
        if (nums[i] != 0) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j++] = tmp;
        }
    }
}

```

---



## 3. 合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
     合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**示例 2：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
     合并结果是 [1] 。
```

**示例 3：**

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
     合并结果是 [1] 。
     注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

 

**提示：**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[j] <= 109`



### 解法：逆序双指针

观察可知，`nums1` 的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进 `nums1` 的最后面。

严格来说，在此遍历过程中的任意一个时刻，`nums1` 数组中有 $m−p_1−1$ 个元素被放入 `nums1` 的后半部，`nums2` 数组中有 $n-p_2-1$ 个元素被放入 `nums1` 的后半部，而在指针 $p_1$ 的后面，`nums1` 数组有 $m+n−p_1−1$ 个位置。由于

$m+n−p_1−1≥m−p_1−1+n−p_2−1$

等价于

$p_2≥−1$

永远成立，因此 $p_1$ 后面的位置永远足够容纳被插入的元素，不会产生 $p_1$​ 的元素被覆盖的情况。

**注意，考虑两种边界情况**

即 `nums1` 的指针为 $i$，`nums2` 的指针为 $j$，末尾指针为 $cur$

1. $nums1[0] < nums2[0]$：此时 $i = -1$，$j != -1$，且 $cur != 0$，需要继续遍历 `nums2`
2. $nums2[0] < nums1[0]$：此时 $j=-1$，$i != -1$，且 $cur != 0$，需继续遍历 `nums1`

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1, cur = m + n - 1;
    while (i>=0 || j >= 0) {
        if (i == -1) {
            nums1[cur] = nums2[j];
            j--;
        } else if (j == -1) {
            nums1[cur] = nums1[i];
            i--;
        } else if (nums1[i] > nums2[j]) {
            nums1[cur] = nums1[i];
            i--;
        } else {
            nums1[cur] = nums2[j];
            j--;
        }
        cur--;
    }
}
```

